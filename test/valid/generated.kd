capability Drive(float x, float y) {
  action "/navigate_to_pose" "nav2_msgs::action::NavigateToPose::Goal"{
    trigger:  void to_position(float x, float y);
    abort:  void abort();
    return:  void in_position(float x, float y);
    error:  void path_blocked();
  }
}
capability Grip(boolean grip) {
  action "/handler/action" "std_msgs::String"{
    trigger:  void handle(bool grip);
    abort:  void cancel();
    return:  void handled();
    error:  void failed();
  }
}
capability Vision() {
  action "/recognize" "std_msgs::String"{
    trigger:  void recognize();
    abort:  void cancel();
    return:  void found();
  }
}

task pickandplace(drive req Drive, grip req Grip, vision req Vision, float x1, float y1, float x2, float y2)
{
  trigger:  void start(float x1, float y1, float x2, float y2);
  abort:  void abort();
  return:  void done();
  error:  void failed();
  vars {
    float x1_ = x1 : 0
    float y1_ = y1 : 0
    float x2_ = x2 : 0
    float y2_ = y2 : 0
  }

  strategy {
    loop: (drive(x1_, y1_) on error (err) on abort (err)) --> pick --> (drive(x2_, y2_) on error (err) on abort (err)) --> drop;
    main: repeat(loop);
    pick: (within 30000 do ((vision() on abort (err))) else (err)) --> (grip(true) on error (err) on abort (err));
    drop: (grip(false) on error (err) on abort (err));
    err: drive.abort() --> grip.cancel() --> vision.cancel() --> end;
  }
}
